# ダンジョン生成 アルゴリズム改善案

本提案は現行コード（main.js）の生成ロジックを踏まえ、近年広く用いられる手法・実践知に基づいて、多様性・連結性・遊び心地を強化する改善プランです。主要な参考URLは末尾の「参考URL」に記載します。

## 現状と課題

- 現状のタイプ（抜粋）：
  - field/cave/maze/rooms/single-room/circle/narrow-maze/wide-maze/snake/mixed（main.js:258, 272, 305, 348, 575, 591, 609, 694, 812, 976）
  - 連結保証：flood fill → 未到達タイルを最近傍タイルに直線接続（main.js:514）
- 課題（傾向）：
  - 直線的な接続が多く単調になりやすい（直線トンネルの量、分岐・輪の少なさ）
  - rooms は隣接部屋の直結が中心で、全体の通路網が均一化しやすい
  - cave はセルオートマトン中心で、パラメータ変化はあるが構造のバリエーションが限定的
  - snake は一本道で緊張感はあるが、回や分岐のコントロールが弱い

## 改善方針（全体）

- グラフ志向の接続設計（部屋中心のDelaunay→MST→余剰辺）でネットワーク多様性を確保
- 連結保証を「A*で掘る」へ拡張し、壁厚や曲率を制御して自然な通路に
- 部屋配置は Poisson Disk（ブルーノイズ）で重複回避・均等感と偏りの両立
- 洞窟は「ドランカードウォーク（制約付き）」とセルオートマトンを併用し、洞窟/回廊/広間の比率を制御
- テーマ性（WFC等）をミクロ構造で適用し、見た目とプレイフィールを差別化

---

## 1) 部屋配置と接続の最適化（Rooms系）

### 1-1. Poisson Disk Sampling による非重複・安定配置

- 目的: ランダム配置の試行錯誤回数を削減しつつ、部屋同士の近接と空白をバランスよく確保
- 方法:
  - マップ内に最小間隔rで点をサンプリング → 点ごとに部屋サイズ（最小/最大）を割当 → はみ出し/重複を微調整
- 効果: 極端な重なりや偏りが減り、通路設計の自由度が上がる
- 参考: Bridson 2007 の高速Poisson-Disc（実装・解説: Jason Davies）

### 1-2. Delaunay Triangulation → MST → 余剰エッジ

- 目的: 自然な通路網の骨格を作る（最短接続＋適度なループ）
- 方法:
  1) 部屋中心点の Delaunay 三角形分割を取得
  2) 辺コスト（ユークリッド距離や障害度）で MST を構築
  3) ランダムに一定割合（例20～30%）の非MST辺を追加し、ループと近道を作る
- 効果: 迷いと回遊性が生まれ、一本道/袋小路の過多を回避
- 実装補足（JS）: Delaunayは `Delaunator`（Mapbox）や `d3-delaunay` を参照可能。MSTはKruskal/Primで容易に実装

### 1-3. A* 掘削の通路生成（コスト場で曲率制御）

- 目的: 単なる直線ではなく「壁厚を避ける/曲がりを持つ」通路を生成
- 方法:
  - コストマップ：壁=高コスト、既存床=低コスト、直線ペナルティ/曲率ペナルティを可変
  - A* で経路を取得し、その経路を床として「掘る」
- パラメータ:
  - straightness（直線好み）/curviness（曲率好み）/hugWalls（壁沿い好み）など
- 置換点: `createCorridor()` を A* 掘削版に差し替え（main.js:502）
- 参考: Red Blob Games のA*解説（実装・ヒューリスティック設計）

---

## 2) 洞窟系の多様化（Cave/Cavern）

### 2-1. 制約付きドランカードウォーク（Random Walk）

- 目的: 洞窟や湾曲した回廊を直感的に制御
- 方法:
  - ウォーカが一定目標（掘削タイル数/占有率）までランダム移動しながら掘る
  - 方向転換率、枝分かれ頻度、部屋（ラージチャンバー）挿入率をパラメータ化
  - 終了後に1～2回のセルオートマトンで形状を整える
- 効果: セルオートマトン単体よりもバリエーションが出やすい
- 参考: RogueBasin「Drunkard's Walk」

### 2-2. マルチパス+後処理

- 目的: 連結性/視界/戦略性の調整
- 方法:
  - 複数ウォーカ（起点分散）→ 重要ノード（広間）間を A* で接続
  - 細通路/広間の比率を調整、視界射線の確保（細長すぎない）

---

## 3) 連結保証の高度化

### 3-1. コンポーネント接続の最短路掘削

- 目的: 「直線一発繋ぎ」を脱却して、自然な接続に
- 方法:
  - 連結成分を抽出 → 成分間の代表点ペアに A* で通路を掘削
  - 代表点は重心 or 出入口候補（壁沿いのタイル）
- 置換点: `ensureConnectivity()` の接続部（main.js:550以降）

### 3-2. 階段・初期位置の安全配置

- 目的: 初期湧きや階段が即座に危険地帯に隣接しない
- 方法:
  - spawn/階段は敵とのマンハッタン距離や視界を閾値以上に確保
  - フェイルセーフとして数回リロケート

---

## 4) テーマ生成（WFC 等）

### 4-1. Wave Function Collapse（WFC）によるタイル配置

- 目的: ミクロ構造（パターン）をルールで生成し、見た目や動線の特徴を付与
- 方法:
  - 既存のフロア/壁を「下地」とし、壁模様/床装飾/小部屋パターンを WFC で敷設
  - 生成後に到達性と視界を再検証
- 注意: 計算量と失敗時のリトライをケア（小領域への適用から）
- 参考: mxgmn/WaveFunctionCollapse（オリジナル実装と多数の解説）

---

## 5) 配置の知的化（敵/宝箱）

- Poisson Disk で敵/宝箱を分散配置（密集/スカスカの極端を回避）
- 危険度スコアに応じた配置（通路幅、交差点、目標物周辺）で読み合い促進
- 宝箱は「視線が通らない曲がり角の先」等に重み付け（探索の満足度↑）

---

## 6) 実装ガイド（最小侵襲での導入）

- 新規ユーティリティ
  - `aStarPath(grid, start, goal, costFn)`
  - `poissonDisk(width, height, r)`（2D点集合）
  - `delaunay(points)` → `minimumSpanningTree(edges)`
- 差し替え/拡張ポイント
  - `createCorridor()` → A* 掘削版（曲率/壁厚ペナルティ）
  - `ensureConnectivity()` → 成分間A*接続
  - `generateRoomsType()` → Poisson配置＋Delaunay→MST→余剰辺
  - `generateCaveType()` → ドランカードウォーク＋軽スムージング
- 互換性
  - 外周壁/4近傍到達性の不変は維持
  - エンティティ計数式（(W+H)/8, (W+H)/15）は踏襲（bias係数で拡張可）

### 6-1. 追加の最適化オプション（任意）

- パス探索の高速化: ジャンプポイントサーチ（JPS）はグリッドA*を大幅高速化可能（JPSは最適性維持）。大域的探索が重くなる場合の導入候補
- 階層経路探索: HPA*（階層化）で広域マップ時の探索ノードを削減（生成時の多点間最短路が多い場合に有効）
- 注: 本ゲームの通路掘削は1対1の経路取得が主であり、まずは素直なA*＋よいヒューリスティックで十分。性能が問題化した段階で検討

---

## 7) 疑似コード例

### 7-1. Rooms: Delaunay→MST→A* 掘削

```
rooms = placeRoomsByPoisson(width, height, r, sizeRange)
centers = rooms.map(center)
tri = delaunay(centers)
edges = tri.edgesWithCost()
mst = minimumSpanningTree(edges)
extra = pickNonMstEdges(edges, ratio=0.25)
for (u,v) in mst ∪ extra:
  path = aStarPath(map, u.center, v.center, costFn)
  dig(path)
```

### 7-2. Component接続のA*

```
components = connectedComponents(map)
while components.count > 1:
  (A,B) = pickClosestComponents(components)
  (sa,sb) = pickBoundaryPortals(A,B)
  path = aStarPath(map, sa, sb, costFn)
  dig(path)
  components = connectedComponents(map) // 再評価
```

### 7-3. ドランカードウォーク洞窟

```
map = allWalls()
walker = randomStart()
while carved < target or steps < max:
  dig(walker.pos)
  if rand() < turnRate: walker.dir = randomDir()
  if rand() < branchRate: spawnWalker()
  walker.step()
map = cellularAutomata(map, iterations=1..2, rule=5/4)
ensureConnectivityWithAStar()
```

---

## 8) 設計/計算量/保守

- Delaunay/MST は部屋数Nに対し O(N log N)〜O(N^2)（実装依存）。A* は通路長Lに比例（ヒューリスティックで高速）
- コスト関数を1か所に集約して、通路の性格（直線/曲率/壁沿い）をゲーム設定から調整可能に
- 現行APIやデータ構造（0/1グリッド、外周壁、座標系）を維持して差分導入
- 再現性: 乱数はシード化（例: Mulberry32/xoshiro）し、選択画面→生成→配置で同一シード同一結果を保証
- 品質指標: ループ数、袋小路数、平均通路幅、連結成分の一時数などをログ出力して回帰テスト

---

## 9) 段階導入プラン

1. `createCorridor` と `ensureConnectivity` の A* 化（既存の地形に自然な通路を導入）
2. `generateRoomsType` の Delaunay→MST→余剰辺 置換（通路網の多様化）
3. `generateCaveType` のドランカードウォーク併用（洞窟の表情付け）
4. 敵/宝箱の Poisson 分散、危険度スコア重み
   5.（任意）WFC を装飾/小部屋パターンへ適用

---

## 10) 参考URL

- A* Pathfinding（実装・解説）: https://www.redblobgames.com/pathfinding/a-star/introduction.html
- Poisson-Disc（Bridson 2007 解説/実装リンク）: https://www.jasondavies.com/poisson-disc/
- Delaunay Triangulation（JS実装 Delaunator）: https://mapbox.github.io/delaunator/
- MST（解説/実装方針・Kruskal）: https://cp-algorithms.com/graph/mst_kruskal.html
- Cellular Automata Caves（RogueBasin）: http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels
- Drunkard's Walk（RogueBasin）: http://www.roguebasin.com/index.php?title=Random_Walk_Cave_Generation
- Wave Function Collapse（公式リポジトリ）: https://github.com/mxgmn/WaveFunctionCollapse
- Jump Point Search（解説/論文）: https://harablog.wordpress.com/2011/09/07/jump-point-search/ （AAAI 2011）

---

## 11) 現行コードへの具体マッピング

- `main.js:502` createCorridor を A* 掘削に置換
- `main.js:514` ensureConnectivity を成分間A*接続に拡張
- `main.js:348` generateRoomsType を Poisson配置＋Delaunay→MST→余剰辺に刷新
- `main.js:272` generateCaveType にドランカードウォーク前段を追加（後段で既存のスムージングを併用）

補足: JS実装における具体ライブラリとしては `Delaunator` の参照が有用（Delaunay→MST）、Poisson-DiscはBridson法をそのまま実装可能。A*はRed Blobの実装解説に準拠して最小限で導入できます。パラメータ初期値（例）: 余剰辺比率0.25、Poisson r=roomMean*0.6、A*の直線ペナルティ=0.2、壁沿い好み=0.1 から調整開始。
