# ブロック次元の設計

本ドキュメントは、選択画面に「ブロック次元」モードを追加し、次元(a..z)と3つのブロック(1st/2nd/3rd)の組み合わせからダンジョン仕様を合成する機能の詳細設計です。UI/データ/生成/永続化の変更点、擬似コード、導入手順、既存コードへの差分を具体化します。

## 目的 / 要件
- 目的: 通常ワールドとは別系統の多様な生成パラメータをプレイヤーが組み合わせ可能にする
- 互換: 既存の通常ワールド選択と併存（削除なし）。既存の難易度・UI・永続化は維持
- 侵襲度: `main.js` の生成・UI・永続化に最小限の分岐を追加する方針
- 再現性: 次元/ブロック選択から同一シードを導出可能に（同選択→同生成）

## 用語
- 次元(Dimension): a..z（各100刻みベースレベルを持つ）
- ブロック(Block): 1st/2nd/3rd 各100種（レベル補正/サイズ係数/深さ/宝箱バイアス/タイプ優先/ボス階層）
- 合成(Compose): 次元と3ブロックからラン生成用Specを導出する処理

## データモデル

### 型（擬似TS）
```ts
type ChestBias = 'less' | 'normal' | 'more';
type GenType = 'field'|'cave'|'narrow-maze'|'wide-maze'|'rooms'|'single-room'|'circle'|'snake'|'grid'|'open-space'|'mixed'|'circle-rooms'; // grid/open-space は混合型のみ出現

type Dimension = { key: string; name: string; baseLevel: number }; // a..z
type Block = {
  key: string;
  level?: number;   // 推奨Lv補正（±）
  size?: number;    // マップサイズ係数（-2..+2 目安）
  depth?: number;   // 深さ補正（±）
  chest?: ChestBias;// 宝箱量バイアス
  type?: GenType | null; // タイプ優先（後勝ち）
  bossFloors?: number[]; // 特定フロアでボス
};

type ComposedSpec = {
  level: number;        // 推奨Lv
  sizeFactor: number;   // -2..+2 程度
  depth: number;        // 1..15（上限）
  chestBias: ChestBias; // less/normal/more
  type: GenType;        // 生成タイプ（BlockDimでは常に 'mixed'）
  typePool?: GenType[]; // 混合対象（ブロックが指示したタイプのみ）
  bossFloors: number[]; // 出現階
};

type BlockDimState = {
  enabled: boolean;
  nested?: number; // NESTED次元（1..99,999,999）
  dimKey?: string;
  b1Key?: string;
  b2Key?: string;
  b3Key?: string;
  spec?: ComposedSpec;
};
```

### テーブル初期化例（サンプル最小）
```js
const dimensions = [
  { key:'a', name:'Aether', baseLevel:1 },
  { key:'b', name:'Basalt', baseLevel:101 },
  // ... z まで 100刻み
];

const blocks1 = [
  { key:'verdant',  level:+10, size: 0, depth:+2, chest:'normal', type:null,           bossFloors:[10] },
  { key:'compact',  level:  0, size:-1, depth:-1, chest:'less',   type:'rooms',        bossFloors:[]   },
];
const blocks2 = [
  { key:'cryptic',  level:+25, size:+1, depth: 0, chest:'more',   type:'cave',         bossFloors:[]   },
  { key:'serpents', level:+15, size: 0, depth:+1, chest:'normal', type:'snake',        bossFloors:[5]  },
];
const blocks3 = [
  { key:'labyrinth',level:  0, size: 0, depth:+3, chest:'more',   type:'narrow-maze',  bossFloors:[5,10,15] },
  { key:'ringed',   level:  0, size:+1, depth: 0, chest:'less',   type:'circle-rooms', bossFloors:[]       },
];
```

## 合成ロジック

### 補助関数（擬似コード）
```js
function clamp(min, max, v) { return Math.max(min, Math.min(max, v)); }
function majority(arr /* ['less','more','normal'] */) {
  const cnt = { less:0, normal:0, more:0 };
  for (const v of arr) if (v) cnt[v]++;
  // 同数のとき normal 優先 → more → less の順
  if (cnt.normal >= cnt.more && cnt.normal >= cnt.less) return 'normal';
  if (cnt.more   >= cnt.less) return 'more';
  return 'less';
}
function pickPriority(arr /* [t3,t2,t1] */) {
  for (const t of arr) if (t) return t; // 後段優先（3rd→2nd→1st）
  return null;
}
function unionNormalize(listOfLists) {
  const s = new Set();
  for (const lst of listOfLists) for (const x of (lst||[])) s.add(x);
  return Array.from(s).sort((a,b)=>a-b);
}
```

### 合成本体（擬似コード）
```js
function composeSpec(dim, b1, b2, b3, nested = 1) {
  const base = dim.baseLevel;
  const nestedOffset = 2600 * Math.max(0, (nested|0) - 1);
  const level = base + (b1.level||0) + (b2.level||0) + (b3.level||0) + nestedOffset;
  const sizeFactor = (b1.size||0) + (b2.size||0) + (b3.size||0);   // -2..+2 目安
  const depth = clamp(1, 15, 1 + (b1.depth||0) + (b2.depth||0) + (b3.depth||0));
  const chestBias = majority([b1.chest, b2.chest, b3.chest]);
  // 新仕様: タイプは3ブロックの type の和集合のみから毎階層ランダム（=混合）
  const pool = [b1.type, b2.type, b3.type].filter(Boolean);
  const typePool = Array.from(new Set(pool));
  const type = 'mixed';
  const bossFloors = unionNormalize([b1.bossFloors, b2.bossFloors, b3.bossFloors]);
  return { level, sizeFactor, depth, chestBias, type, typePool, bossFloors };
}
```

### シード導出（再現性）
```js
function seedFromSelection(dimKey, b1Key, b2Key, b3Key) {
  const str = `${dimKey}|${b1Key}|${b2Key}|${b3Key}`;
  // 32bit ハッシュ（例: xfnv1a）→ Mulberry32 などに投入
  return hash32(str);
}
```
※ 既定では NESTED はシードに含めない（同一選択+NESTED差分で“同構造・別難易度”を実現）。

### 履歴/ブックマーク
- キー `bdimKey` は `nested|dimKey|b1|b2|b3` として NESTED を含めて区別する。
- 表示には `NESTED n` を含める（プレビュー/モーダル/履歴）。

## UI 仕様

### 画面構成（選択画面タブ追加）
- タブ: `Normal` / `BlockDim`（ID: `tab-normal`, `tab-blockdim`）
- `BlockDim`タブ内フォーム（IDs）
  - `bdim-nested`（NESTED次元: 数値入力、min=1, max=99_999_999, step=1, default=1）
  - `bdim-select-dimension`（a..z）
  - `bdim-select-1st`, `bdim-select-2nd`, `bdim-select-3rd`
  - 詳細カード（派生特性プレビュー）
    - `bdim-card-level`, `bdim-card-type`, `bdim-card-depth`, `bdim-card-size`, `bdim-card-chest`, `bdim-card-boss`
  - 入場ボタン: `bdim-start-button`（Gate）

### イベント（擬似コード）
```js
function initBlockDimUI() {
  // セレクト初期化、前回選択の復元
  const nested = clamp(1, 99999999, (loadState()?.blockDim?.nested|0) || 1);
  document.getElementById('bdim-nested').value = nested;
}
function onBlockDimChanged() {
  const nested = clamp(1, 99999999, parseInt(document.getElementById('bdim-nested').value)||1);
  const dim = getSelected(dimensions, 'bdim-select-dimension');
  const b1  = getSelected(blocks1, 'bdim-select-1st');
  const b2  = getSelected(blocks2, 'bdim-select-2nd');
  const b3  = getSelected(blocks3, 'bdim-select-3rd');
  const spec = composeSpec(dim, b1, b2, b3, nested);
  renderPreviewCard(spec);
  blockDimState = { enabled:true, nested, dimKey:dim.key, b1Key:b1.key, b2Key:b2.key, b3Key:b3.key, spec };
}
function onBlockDimStart() {
  applyComposedSpecToRuntime(blockDimState.spec);
  startGameInBlockDimMode();
}
```

## 生成パイプライン接続

### サイズ/タイプ/深さ/宝箱/ボスの反映
```js
// main.js:73 付近 updateMapSize の拡張
function updateMapSize() {
  const base = 15 + dungeonLevel * 5;
  const sizeAdj = (blockDimState.enabled ? (blockDimState.spec.sizeFactor||0) : 0);
  // 係数→タイル数へマッピング（1段階=±2 タイル程度）
  const delta = sizeAdj * 2;
  MAP_WIDTH  = Math.max(15, base + delta);
  MAP_HEIGHT = Math.max(15, base + delta);
}

// main.js:196 付近 generateMap のタイプ決定
// BlockDim では type は 'mixed' 固定。generateMixedType 内で spec.typePool を優先利用
const dungeonData = blockDimState.enabled ? { type:blockDimState.spec.type } : dungeonInfo[selectedDungeonBase];

// main.js:generateEntities で宝箱スケール
const chestBase = (MAP_WIDTH + MAP_HEIGHT) / 15;
const chestMul = !blockDimState.enabled ? 1.0 : (blockDimState.spec.chestBias==='less'?0.7: blockDimState.spec.chestBias==='more'?1.3:1.0);
const chestCount = Math.round(chestBase * chestMul);

// フロア深さとボス判定（10F/25F規定に優先）
function isBossFloor(level) {
  if (blockDimState.enabled) {
    return blockDimState.spec.bossFloors.includes(level);
  }
  // 既存ロジックへフォールバック
  return (selectedWorld==='X' ? level===25 : level===10);
}
```

### 推奨レベル/詳細カード
```js
function recommendedLevelForSelection() {
  if (blockDimState.enabled) return blockDimState.spec.level; // NESTEDオフセット込み
  // 既存の world/dungeon ベースの計算
}
```

### RNGシード固定
```js
function reseedIfBlockDim() {
  if (!blockDimState.enabled) return;
  const seed = seedFromSelection(blockDimState.dimKey, blockDimState.b1Key, blockDimState.b2Key, blockDimState.b3Key);
  rng = mulberry32(seed);
}
```

## 永続化 / マイグレーション

### 保存項目の追加
- 追加: `blockDimState`（`enabled`, `dimKey`, `b1Key`, `b2Key`, `b3Key`）
- 互換: 既存キーは維持。バージョンは同一でも可（未設定時は `enabled:false` ）

```js
// main.js:155 saveAll 追記（擬似）
localStorage.setItem('roguelike_save_v1', JSON.stringify({
  // 既存 ...
  blockDim: blockDimState.enabled ? {
    enabled:true, nested, dimKey, b1Key, b2Key, b3Key
  } : { enabled:false }
}));

// 読込時: 無ければ enabled:false 既定
```

## インポート/エクスポート
- JSONに `blockDim` を含める。存在しないデータは無視/既定

## バリデーション
- 深さ: `1 <= depth <= 15`
- サイズ: `sizeFactor ∈ [-2..+2]`（越えは丸め）
- ボス階: `1..depth` のみ採用
- 推奨Lv: `>=1`

## テレメトリ（開発時ログ）
- 合成Specと派生: `{level, sizeFactor, depth, chestBias, type, bossFloors}` を選択時にlog
- 生成後: 連結成分数/袋小路数/ループ推定を簡易集計（既存のensureConnectivity後）

## UI詳細（HTML 追加案）

```html
<!-- index.html: BlockDim タブ（概略） -->
<div id="tab-blockdim" class="tab">
  <select id="bdim-select-dimension"></select>
  <select id="bdim-select-1st"></select>
  <select id="bdim-select-2nd"></select>
  <select id="bdim-select-3rd"></select>
  <div id="bdim-card">
    <div>推奨Lv: <span id="bdim-card-level"></span></div>
    <div>タイプ: <span id="bdim-card-type"></span></div>
    <div>深さ: <span id="bdim-card-depth"></span></div>
    <div>サイズ: <span id="bdim-card-size"></span></div>
    <div>宝箱: <span id="bdim-card-chest"></span></div>
    <div>ボス階: <span id="bdim-card-boss"></span></div>
  </div>
  <button id="bdim-start-button">Gate</button>
  <small>同一選択は同一生成（固定シード）</small>
  </div>
```

## 実装ステップ（詳細）
1) データ/状態
  - `dimensions`, `blocks1/2/3`, 補助関数、`composeSpec` を `main.js` 末尾付近へ追加
  - `blockDimState` グローバル追加（既定 `enabled:false`）
2) UI
  - タブ/セレクト/カード/ボタンのHTMLを追加
  - 初期化`initBlockDimUI`とイベント`onBlockDimChanged/onBlockDimStart`を追加
3) 生成
  - `updateMapSize()` に sizeFactor 反映（`main.js:73`）
  - `generateMap()` のタイプ決定に `spec.type` を使用（`main.js:196`）
  - `generateEntities()` で宝箱数のバイアス反映、ボス階層の判定統一
  - RNGを `reseedIfBlockDim()` で再シード
4) 永続化
  - `saveAll()`/復元に `blockDimState` を追加（`main.js:155`）
5) 表示
  - 推奨Lvカードの計算で `recommendedLevelForSelection()` をブロック次元対応
6) QA
  - 深さ境界/サイズ最小値/ボス階層の条件を単体で検証、既存の連結/配置不変条件も回す

## 擬似コード（フックまとめ）
```js
// ラン開始フロー（BlockDim）
function startGameInBlockDimMode() {
  blockDimState.enabled = true;
  reseedIfBlockDim();
  dungeonLevel = 1;
  updateMapSize();
  generateMap();
  generateEntities();
  // 既存のゲーム開始処理へ
}

function renderPreviewCard(spec) {
  setText('bdim-card-level', spec.level);
  setText('bdim-card-type', spec.type==='mixed' && spec.typePool?.length
    ? `混合型（${spec.typePool.join('＋')}）`
    : spec.type);
  setText('bdim-card-depth', spec.depth);
  setText('bdim-card-size', spec.sizeFactor);
  setText('bdim-card-chest', spec.chestBias);
  setText('bdim-card-boss', spec.bossFloors.join(','));
}
```

## 既存コードへの差分（実装時の編集ポイント）

- 追加するコード
  - `main.js` 末尾: `dimensions/blocks1/blocks2/blocks3` テーブル・補助関数・`composeSpec`・`blockDimState`・RNGリシード
  - `main.js` UI初期化: `initBlockDimUI/onBlockDimChanged/onBlockDimStart` とイベント登録
  - `index.html` 選択画面に BlockDim タブ群（前節HTML）

- 変更するコード
  - `main.js:73` `updateMapSize()` に `sizeFactor` 反映
  - `main.js:196` `generateMap()` のタイプ決定で `blockDimState.spec.type` を優先
  - `main.js:... generateEntities()` 内で宝箱数スケールとボス階層判定
  - `main.js:155` `saveAll()` と読込側に `blockDimState` を追加
  - 推奨Lv計算/カード更新（選択画面）を `blockDimState` 対応

- 削除するコード
  - なし（通常ワールド選択は維持）。将来、BlockDim導入後に重複仕様を整理する場合は `dungeonInfo` の一部を統合候補とする

## 非機能
- パフォーマンス: 合成自体は軽量。選択変更時のプレビューは同フレームで完了
- 安全域: 極端な `sizeFactor/depth` はクランプして視認性と連結性を維持

## リスク/対応
- ブロックテーブル100×3の拡張: 初期は10〜20件で検証し、順次拡大
- 生成タイプの偏り: `type`未設定時は'mixed'で全体バランス維持

## ロールアウト
1. コア合成/UI/フックのみ（通常ワールド併存）
2. ブロックテーブルを段階拡張、ボス階層/テーマ性を充実
3. 以後、`アルゴリズム改善案.md` の手法（A*掘削/Poisson/MST 等）と連携
