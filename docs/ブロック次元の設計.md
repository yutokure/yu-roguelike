# ブロック次元の設計

本ドキュメントは、選択画面に「ブロック次元」モードを追加し、次元(a..z)と3つのブロック(1st/2nd/3rd)の組み合わせからダンジョン仕様を合成する機能の詳細設計です。UI/データ/生成/永続化の変更点、擬似コード、導入手順、既存コードへの差分を具体化します。

## 目的 / 要件
- 目的: 通常ワールドとは別系統の多様な生成パラメータをプレイヤーが組み合わせ可能にする
- 互換: 既存の通常ワールド選択と併存（削除なし）。既存の難易度・UI・永続化は維持
- 侵襲度: `main.js` の生成・UI・永続化に最小限の分岐を追加する方針
- 再現性: 次元/ブロック選択から同一シードを導出可能に（同選択→同生成）

## 用語
- 次元(Dimension): a..z（各100刻みベースレベルを持つ）
- ブロック(Block): 1st/2nd/3rd 各100種（レベル補正/サイズ係数/深さ/宝箱バイアス/タイプ優先/ボス階層）
- 合成(Compose): 次元と3ブロックからラン生成用Specを導出する処理

## データモデル

### 型（擬似TS）
```ts
type ChestBias = 'less' | 'normal' | 'more';
type GenType = 'field'|'cave'|'narrow-maze'|'wide-maze'|'rooms'|'single-room'|'circle'|'snake'|'grid'|'open-space'|'mixed'|'circle-rooms'; // grid/open-space は混合型のみ出現

type Dimension = { key: string; name: string; baseLevel: number }; // a..z
type Block = {
  key: string;
  level?: number;   // 推奨Lv補正（±）
  size?: number;    // マップサイズ係数（-2..+2 目安）
  depth?: number;   // 深さ補正（±）
  chest?: ChestBias;// 宝箱量バイアス
  type?: GenType | null; // タイプ優先（後勝ち）
  bossFloors?: number[]; // 特定フロアでボス
};

type ComposedSpec = {
  level: number;        // 推奨Lv
  sizeFactor: number;   // -2..+2 程度
  depth: number;        // 1..15（上限）
  chestBias: ChestBias; // less/normal/more
  type: GenType;        // 生成タイプ（BlockDimでは常に 'mixed'）
  typePool?: GenType[]; // 混合対象（ブロックが指示したタイプのみ）
  bossFloors: number[]; // 出現階
};

type BlockDimState = {
  enabled: boolean;
  nested?: number; // NESTED次元（1..99,999,999）
  dimKey?: string;
  b1Key?: string;
  b2Key?: string;
  b3Key?: string;
  spec?: ComposedSpec;
  seed?: number; // 選択組み合わせに紐づく32bitシード
};

type BlockDimHistoryEntry = {
  key: string;
  nested: number;
  dim: string;
  b1: string;
  b2: string;
  b3: string;
  level: number;
  depth: number;
  type: string;
  seed: number;
};
```

### テーブル初期化例（サンプル最小）
```js
const dimensions = [
  { key:'a', name:'Aether', baseLevel:1 },
  { key:'b', name:'Basalt', baseLevel:101 },
  // ... z まで 100刻み
];

const blocks1 = [
  { key:'verdant',  level:+10, size: 0, depth:+2, chest:'normal', type:null,           bossFloors:[10] },
  { key:'compact',  level:  0, size:-1, depth:-1, chest:'less',   type:'rooms',        bossFloors:[]   },
];
const blocks2 = [
  { key:'cryptic',  level:+25, size:+1, depth: 0, chest:'more',   type:'cave',         bossFloors:[]   },
  { key:'serpents', level:+15, size: 0, depth:+1, chest:'normal', type:'snake',        bossFloors:[5]  },
];
const blocks3 = [
  { key:'labyrinth',level:  0, size: 0, depth:+3, chest:'more',   type:'narrow-maze',  bossFloors:[5,10,15] },
  { key:'ringed',   level:  0, size:+1, depth: 0, chest:'less',   type:'circle-rooms', bossFloors:[]       },
];
```

### データ読込

- 既定では `blockdata.json` を `fetch` で取得し、`dimensions/blocks1/blocks2/blocks3` を初期化。
- `file://` 環境や失敗時は `blockdata.js`（`window.__BLOCKDATA` を公開）を `<script>` で読み込みフォールバック。
- いずれも読み込み後に `blockDimTables.__loaded = true` とし、待機中の初期化処理 (`flushPendingDungeonBlocks`) を解放。

## 合成ロジック

### 補助関数（擬似コード）
```js
function clamp(min, max, v) { return Math.max(min, Math.min(max, v)); }
function majority(arr /* ['less','more','normal'] */) {
  const cnt = { less:0, normal:0, more:0 };
  for (const v of arr) if (v) cnt[v]++;
  // 同数のとき normal 優先 → more → less の順
  if (cnt.normal >= cnt.more && cnt.normal >= cnt.less) return 'normal';
  if (cnt.more   >= cnt.less) return 'more';
  return 'less';
}
function pickPriority(arr /* [t3,t2,t1] */) {
  for (const t of arr) if (t) return t; // 後段優先（3rd→2nd→1st）
  return null;
}
function unionNormalize(listOfLists) {
  const s = new Set();
  for (const lst of listOfLists) for (const x of (lst||[])) s.add(x);
  return Array.from(s).sort((a,b)=>a-b);
}
```

### 合成本体（擬似コード）
```js
function composeSpec(dim, b1, b2, b3, nested = 1) {
  const base = dim.baseLevel;
  const nestedOffset = 2600 * Math.max(0, (nested|0) - 1);
  const level = base + (b1.level||0) + (b2.level||0) + (b3.level||0) + nestedOffset;
  const sizeFactor = (b1.size||0) + (b2.size||0) + (b3.size||0);   // -2..+2 目安
  const depth = clamp(1, 15, 1 + (b1.depth||0) + (b2.depth||0) + (b3.depth||0));
  const chestBias = majority([b1.chest, b2.chest, b3.chest]);
  // 新仕様: タイプは3ブロックの type の和集合のみから毎階層ランダム（=混合）
  const pool = [b1.type, b2.type, b3.type].filter(Boolean);
  const typePool = Array.from(new Set(pool));
  const type = 'mixed';
  const bossFloors = unionNormalize([b1.bossFloors, b2.bossFloors, b3.bossFloors]);
  return { level, sizeFactor, depth, chestBias, type, typePool, bossFloors };
}
```

### シード導出（再現性）
```js
function seedFromSelection(dimKey, b1Key, b2Key, b3Key) {
  const str = `${dimKey}|${b1Key}|${b2Key}|${b3Key}`;
  // 32bit ハッシュ（例: xfnv1a）→ Mulberry32 などに投入
  return hash32(str);
}
```
※ 既定では NESTED はシードに含めない（同一選択+NESTED差分で“同構造・別難易度”を実現）。

### 履歴/ブックマーク
- キー `bdimKey` は `nested|dimKey|b1|b2|b3` として NESTED を含めて区別する。
- 表示には `NESTED n` を含める（プレビュー/モーダル/履歴）。

## UI 仕様

### 画面構成（選択画面タブ追加）
- タブ: `Normal` / `BlockDim`（ID: `tab-normal`, `tab-blockdim`）
- `BlockDim`タブ内フォーム（主要ID）
  - `bdim-nested`: NESTED次元（min=1, max=99,999,999）。
  - `bdim-list-dimension`, `bdim-list-1st`, `bdim-list-2nd`, `bdim-list-3rd`: カスタムlistbox。`bdim-option` クラスで選択強調。
  - 詳細カード（派生特性プレビュー）: `bdim-card-selection`, `bdim-card-level`, `bdim-card-type`, `bdim-card-depth`, `bdim-card-size`, `bdim-card-chest`, `bdim-card-boss`。
  - 操作ボタン: `bdim-start-button`（Gate入場）、`bdim-add-bookmark`、`bdim-clear-history`、`bdim-random-button`、`bdim-weighted-random-button`。
  - 追加入力: `bdim-random-target`（合計Lv目標）、`bdim-random-type`（タイプ優先）。
  - 表示領域: `bdim-history`（最新200件）、`bdim-bookmarks`（最大100件）。

### イベント（擬似コード）
```js
async function initBlockDimUI(){
  await loadBlockDataOnce();
  renderBdimLists();
  renderHistoryAndBookmarks();
  const initialNested = clamp(1, 99999999, (loadState()?.blockDim?.nested|0) || 1);
  bdimNestedInput.value = initialNested;
  updateFromSelection();
}

function updateFromSelection(){
  if (!blockDimTables.__loaded) return;
  const nested = clamp(1, 99999999, parseInt(bdimNestedInput.value)||1);
  const dim = findSelected(blockDimTables.dimensions, bdimDimList);
  const b1  = findSelected(blockDimTables.blocks1, bdim1List);
  const b2  = findSelected(blockDimTables.blocks2, bdim2List);
  const b3  = findSelected(blockDimTables.blocks3, bdim3List);
  const spec = composeSpec(dim, b1, b2, b3, nested);
  const seed = seedFromSelection(dim.key, b1.key, b2.key, b3.key);
  blockDimState = { enabled: true, nested, dimKey: dim.key, b1Key: b1.key, b2Key: b2.key, b3Key: b3.key, spec, seed };
  renderBdimPreview(spec);
  bdimStartBtn.disabled = !spec;
}

bdimStartBtn.addEventListener('click', () => {
  if (!blockDimState?.spec) return;
  currentMode = 'blockdim';
  startGameInBlockDimMode();
});
```

## 生成パイプライン接続

### サイズ/タイプ/深さ/宝箱/ボスの反映
```js
// main.js:73 付近 updateMapSize の拡張
function updateMapSize() {
  const base = 15 + dungeonLevel * 5;
  const sizeAdj = (blockDimState.enabled ? (blockDimState.spec.sizeFactor||0) : 0);
  // 係数→タイル数へマッピング（1段階=±2 タイル程度）
  const delta = sizeAdj * 2;
  MAP_WIDTH  = Math.max(15, base + delta);
  MAP_HEIGHT = Math.max(15, base + delta);
}

// main.js:196 付近 generateMap のタイプ決定
// BlockDim では type は 'mixed' 固定。generateMixedType 内で spec.typePool を優先利用
const dungeonData = blockDimState.enabled ? { type:blockDimState.spec.type } : dungeonInfo[selectedDungeonBase];

// main.js:generateEntities で宝箱スケール
const chestBase = (MAP_WIDTH + MAP_HEIGHT) / 15;
const chestMul = !blockDimState.enabled ? 1.0 : (blockDimState.spec.chestBias==='less'?0.7: blockDimState.spec.chestBias==='more'?1.3:1.0);
const chestCount = Math.round(chestBase * chestMul);

// フロア深さとボス判定（10F/25F規定に優先）
function isBossFloor(level) {
  if (blockDimState.enabled) {
    return blockDimState.spec.bossFloors.includes(level);
  }
  // 既存ロジックへフォールバック
  return (selectedWorld==='X' ? level===25 : level===10);
}
```

### 推奨レベル/詳細カード
```js
function recommendedLevelForSelection() {
  if (blockDimState.enabled) return blockDimState.spec.level; // NESTEDオフセット込み
  // 既存の world/dungeon ベースの計算
}
```

### RNGシード固定
```js
function reseedBlockDimForFloor() {
  if (currentMode !== 'blockdim' || !blockDimState?.spec) return;
  const baseSeed = blockDimState.seed ?? seedFromSelection(blockDimState.dimKey, blockDimState.b1Key, blockDimState.b2Key, blockDimState.b3Key);
  blockDimState.seed = baseSeed;
  const floorSeed = mixSeed(baseSeed, dungeonLevel);
  setSeededRandom(floorSeed);
}
```

## 永続化 / マイグレーション

### 保存項目の追加
- 追加: `blockDimState`（`enabled`, `nested`, `dimKey`, `b1Key`, `b2Key`, `b3Key`, `spec`, `seed`）
- 追加: `blockDimHistory`, `blockDimBookmarks`（配列）
- 互換: 既存キーは維持。バージョンは同一でも可（未設定時は `enabled:false` ）

```js
localStorage.setItem('roguelike_save_v1', JSON.stringify({
  // 既存 ...
  blockDim: blockDimState?.enabled ? {
    enabled: true,
    nested: blockDimState.nested || 1,
    dimKey: blockDimState.dimKey,
    b1Key: blockDimState.b1Key,
    b2Key: blockDimState.b2Key,
    b3Key: blockDimState.b3Key,
    spec: blockDimState.spec,
    seed: blockDimState.seed
  } : { enabled:false },
  blockDimHistory,
  blockDimBookmarks
}));

// 読込時: enabled:true なら state と history/bookmarks を復元。未定義なら既定値。
```

## インポート/エクスポート
- JSONに `blockDim` / `blockDimHistory` / `blockDimBookmarks` を含める。存在しないデータは無視/既定

## バリデーション
- 深さ: `1 <= depth <= 15`
- サイズ: `sizeFactor ∈ [-2..+2]`（越えは丸め）
- ボス階: `1..depth` のみ採用
- 推奨Lv: `>=1`

## テレメトリ（開発時ログ）
- 合成Specと派生: `{level, sizeFactor, depth, chestBias, type, bossFloors}` を選択時にlog
- 生成後: 連結成分数/袋小路数/ループ推定を簡易集計（既存のensureConnectivity後）

## UI詳細（HTML 追加案）

```html
<!-- index.html: BlockDim タブ（実装済み構造） -->
<div id="tab-blockdim" class="tab-content" role="tabpanel">
  <div class="row">
    <div class="bdim-field">
      <label for="bdim-nested">NESTED次元</label>
      <input id="bdim-nested" type="number" min="1" max="99999999" step="1" value="1" />
    </div>
  </div>
  <div class="row">
    <div class="bdim-grid">
      <div class="bdim-field"><label>次元</label><div id="bdim-list-dimension" class="bdim-list" role="listbox"></div></div>
      <div class="bdim-field"><label>1st</label><div id="bdim-list-1st" class="bdim-list" role="listbox"></div></div>
      <div class="bdim-field"><label>2nd</label><div id="bdim-list-2nd" class="bdim-list" role="listbox"></div></div>
      <div class="bdim-field"><label>3rd</label><div id="bdim-list-3rd" class="bdim-list" role="listbox"></div></div>
    </div>
  </div>
  <div class="row">
    <div id="bdim-card" class="bdim-card">
      <h3>合成プレビュー</h3>
      <div class="bdim-card-row"><span class="label">選択</span><span id="bdim-card-selection">-</span></div>
      <div class="bdim-card-row"><span class="label">推奨Lv</span><span id="bdim-card-level">-</span></div>
      <div class="bdim-card-row"><span class="label">タイプ</span><span id="bdim-card-type">-</span></div>
      <div class="bdim-card-row"><span class="label">深さ</span><span id="bdim-card-depth">-</span></div>
      <div class="bdim-card-row"><span class="label">サイズ</span><span id="bdim-card-size">-</span></div>
      <div class="bdim-card-row"><span class="label">宝箱</span><span id="bdim-card-chest">-</span></div>
      <div class="bdim-card-row"><span class="label">ボス階</span><span id="bdim-card-boss">-</span></div>
      <small class="bdim-note">同一選択は同一生成（固定シード）</small>
      <div class="bdim-actions">
        <button id="bdim-start-button" class="start-btn" disabled>Gate</button>
        <button id="bdim-add-bookmark">★ ブックマーク追加</button>
        <button id="bdim-clear-history">履歴クリア</button>
      </div>
      <div class="bdim-actions">
        <button id="bdim-random-button">🎲 ランダム選択（1st/2nd/3rd）</button>
      </div>
      <div class="bdim-actions">
        <label for="bdim-random-target">目標Lv(ブロック合計)</label>
        <input id="bdim-random-target" type="number" min="-10" max="102" step="1" value="0" />
        <label for="bdim-random-type">タイプ優先</label>
        <select id="bdim-random-type">
          <option value="">指定なし</option>
          <!-- type候補（field/cave/...） -->
        </select>
        <button id="bdim-weighted-random-button">🎯 重み付きランダム</button>
      </div>
    </div>
  </div>
  <div class="row">
    <div class="bdim-card" id="bdim-history-card"><h3>Gate履歴</h3><div id="bdim-history"></div></div>
  </div>
  <div class="row">
    <div class="bdim-card" id="bdim-bookmarks-card"><h3>ブロックブックマーク</h3><div id="bdim-bookmarks"></div></div>
  </div>
</div>
```

### ランダム選択・履歴/ブックマーク

- `#bdim-random-button`: 1st/2nd/3rd を完全ランダムに選択（現在の次元は維持）。
- `#bdim-weighted-random-button`: 入力された目標Lv/タイプ優先に沿って重み付き抽選。
- `#bdim-history`: Gate突入時に最新200件までスタック。各エントリは `BlockDimHistoryEntry` を保持し、削除ボタンで個別削除。
- `#bdim-bookmarks`: 任意の組み合わせを保存（最大100件）。一覧から Gate ボタンで即選択に復元。
- 履歴/ブックマークは UI 更新後に `saveAll()` へ即時反映。

## 実装ステップ（詳細）
1) データ/状態
  - `dimensions`, `blocks1/2/3`, 補助関数、`composeSpec` を `main.js` 末尾付近へ追加
  - `blockDimState` グローバル追加（既定 `enabled:false`）
2) UI
  - タブ/listbox/カード/ランダム・履歴ボタンのHTMLを追加
  - 初期化`initBlockDimUI`とイベント`renderBdimLists/updateFromSelection/renderHistoryAndBookmarks`を追加
3) 生成
  - `updateMapSize()` に sizeFactor 反映（`main.js:73`）
  - `generateMap()` のタイプ決定に `spec.type` を使用（`main.js:196`）
  - `generateEntities()` で宝箱数のバイアス反映、ボス階層の判定統一
  - RNGを `reseedBlockDimForFloor()` でフロアごとに再シード
4) 永続化
  - `saveAll()`/復元に `blockDimState` を追加（`main.js:155`）
5) 表示
  - 推奨Lvカードの計算で `recommendedLevelForSelection()` をブロック次元対応
6) QA
  - 深さ境界/サイズ最小値/ボス階層の条件を単体で検証、既存の連結/配置不変条件も回す

## 擬似コード（フックまとめ）
```js
// ラン開始フロー（BlockDim）
function startGameInBlockDimMode() {
  currentMode = 'blockdim';
  blockDimState.enabled = true;
  reseedBlockDimForFloor();
  dungeonLevel = 1;
  updateMapSize();
  generateMap();
  generateEntities();
  // 既存のゲーム開始処理へ
}

function renderPreviewCard(spec) {
  if (!spec) return;
  setText('bdim-card-level', spec.level);
  setText('bdim-card-type', spec.type==='mixed' && spec.typePool?.length
    ? `混合型（${spec.typePool.join('＋')}）`
    : spec.type);
  setText('bdim-card-depth', spec.depth);
  setText('bdim-card-size', spec.sizeFactor);
  setText('bdim-card-chest', spec.chestBias);
  setText('bdim-card-boss', spec.bossFloors.join(','));
}
```

## 既存コードへの差分（実装時の編集ポイント）

- 追加するコード
  - `main.js` 末尾: `dimensions/blocks1/blocks2/blocks3` テーブル・補助関数・`composeSpec`・`blockDimState`・RNGリシード
  - `main.js` UI初期化: `initBlockDimUI/renderBdimLists/renderBdimPreview/renderHistoryAndBookmarks` とイベント登録
  - `index.html` 選択画面に BlockDim タブ群（前節HTML）

- 変更するコード
  - `main.js:73` `updateMapSize()` に `sizeFactor` 反映
  - `main.js:196` `generateMap()` のタイプ決定で `blockDimState.spec.type` を優先
  - `main.js:... generateEntities()` 内で宝箱数スケールとボス階層判定
  - `main.js:155` `saveAll()` と読込側に `blockDimState` / `blockDimHistory` / `blockDimBookmarks` を追加
  - 推奨Lv計算/カード更新（選択画面）を `blockDimState` 対応

- 削除するコード
  - なし（通常ワールド選択は維持）。将来、BlockDim導入後に重複仕様を整理する場合は `dungeonInfo` の一部を統合候補とする

## 非機能
- パフォーマンス: 合成自体は軽量。選択変更時のプレビューは同フレームで完了
- 安全域: 極端な `sizeFactor/depth` はクランプして視認性と連結性を維持

## リスク/対応
- ブロックテーブル100×3の拡張: 初期は10〜20件で検証し、順次拡大
- 生成タイプの偏り: `type`未設定時は'mixed'で全体バランス維持

## ロールアウト
1. コア合成/UI/フックのみ（通常ワールド併存）
2. ブロックテーブルを段階拡張、ボス階層/テーマ性を充実
3. 以後、`アルゴリズム改善案.md` の手法（A*掘削/Poisson/MST 等）と連携
